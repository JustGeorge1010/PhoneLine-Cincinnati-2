package com.phonelinecincinnati.game.GameObjects.Objects.Enemies.PathFinding;

import com.badlogic.gdx.math.Vector3;
import com.google.gson.Gson;
import com.google.gson.stream.JsonReader;
import com.phonelinecincinnati.game.GameObjects.Objects.GameDecal;
import com.phonelinecincinnati.game.Main;
import com.phonelinecincinnati.game.Models.TextureName;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class AStarSave {
    private File dataFile;

    /****************************************************************************************************************
     * Save data is stored as two arrays. The first array "nodes" stores the string format of a vector3 position for *
     * each node. The second array "connections" stores two such string vectors for use with linking nodes (Setting  *
     * neighbors)                                                                                                    *
     ****************************************************************************************************************/
    class SaveData {
        ArrayList<String> nodes = new ArrayList<String>();
        HashMap<String, ArrayList<String>> connections = new HashMap<String, ArrayList<String>>();
    }

    public AStarSave(File dataFile) {
        this.dataFile = dataFile;
    }

    public void Save(HashMap<Vector3, Node> nodeMap) {
        // The save method will only be ran if no save exists. Data is generated by the developer ONLY and as such is
        // triggered by simply deleting the data file associated with the level.
        FileOutputStream fos = null;
        try {
            if (dataFile.createNewFile()) {
                fos = new FileOutputStream(dataFile);

                SaveData saveData = new SaveData();
                for (Map.Entry<Vector3, Node> entry : nodeMap.entrySet()) {
                    Node node = entry.getValue();
                    saveData.nodes.add(node.position.toString());
                    ArrayList<String> connections = new ArrayList<String>();
                    for (Node neighbor : node.neighbors) {
                        connections.add(neighbor.position.toString());
                    }
                    saveData.connections.put(node.position.toString(), connections);
                }

                Gson gson = new Gson();
                byte[] bytesArray = gson.toJson(saveData).getBytes();
                fos.write(bytesArray);
                fos.flush();
                System.out.println("File Written Successfully");
            }
        } catch (IOException e) {
            System.out.println("Could not open file '" + dataFile.getName() + "' with following error:");
            e.printStackTrace();
        } finally {
            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException ioe) {
                System.out.println("Error in closing the Stream");
            }
        }
    }

    public HashMap<Vector3, Node> Load() {
        FileInputStream fis = null;
        Reader reader = null;
        HashMap<Vector3, Node> nodeMap = new HashMap<Vector3, Node>();

        try {
            fis = new FileInputStream(dataFile);
            reader = new InputStreamReader(fis);

            Gson gson = new Gson();
            SaveData saveData = gson.fromJson(reader, SaveData.class);

            for(String string : saveData.nodes) {
                Vector3 nodePos = new Vector3().fromString(string);
                nodeMap.put(nodePos, new Node(nodePos));
            }

            for(Node node : nodeMap.values()) {
                ArrayList<String> neighbors = saveData.connections.get(node.position.toString());
                for(String neighbor : neighbors) {
                    Vector3 neighborPos = new Vector3().fromString(neighbor);
                    node.neighbors.add(nodeMap.get(neighborPos));
                }
            }

            System.out.println("Node map loaded Successfully");

        } catch (IOException e) {
            System.out.println("Could not open file '" + dataFile.getName() + "' with following error:");
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException ioe) {
                System.out.println("Error in closing the Stream");
            }
        }

        if(Main.debugDrawPaths) {
            ArrayList<Node> alreadyGenerated = new ArrayList<Node>();
            for(Node node : nodeMap.values()) {
                Main.levelHandler.addObjectToCurrentLevel(new GameDecal(
                        new Vector3(node.position.x, node.position.y+1, node.position.z),
                        0.5f, 0.5f, new Vector3(90, 0, 0), TextureName.BlueCircle));

                for(Node neighbor : node.neighbors) {
                    if(alreadyGenerated.contains(neighbor)) continue;
                    Main.levelHandler.addObjectToCurrentLevel(new DebugPathLine(node.position, neighbor.position));
                    alreadyGenerated.add(node);
                }
            }
        }

        return nodeMap;
    }
}
